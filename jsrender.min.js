/*! JsRender v1.0.0-beta: http://www.jsviews.com/#jsrender
informal pre V1.0 commit counter: 64pre*/
(function (a) {
    if (typeof define === "function" && define.amd) {
        define(a)
    } else {
        if (typeof exports === "object") {
            var b = module.exports = a(true, require("fs"));
            b.renderFile = b.__express = function (e, d, f) {
                var c = b.templates("@" + e).render(d);
                if (f) {
                    f(null, c)
                }
                return c
            }
        } else {
            a(false)
        }
    }
}(function (isCommonJS, fs) {
    isCommonJS = isCommonJS === true;
    var versionNumber = "v1.0.0-beta", global = (0, eval)("this"), $ = global.jQuery, jsvStoreName, rTag, rTmplString, topView, document = global.document, delimOpenChar0 = "{", delimOpenChar1 = "{", delimCloseChar0 = "}", delimCloseChar1 = "}", linkChar = "^", rPath = /^(!*?)(?:null|true|false|\d[\d.]*|([\w$]+|\.|~([\w$]+)|#(view|([\w$]+))?)([\w$.^]*?)(?:[.[^]([\w$]+)\]?)?)$/g, rParams = /(\()(?=\s*\()|(?:([([])\s*)?(?:(\^?)(!*?[#~]?[\w$.^]+)?\s*((\+\+|--)|\+|-|&&|\|\||===|!==|==|!=|<=|>=|[<>%*:?\/]|(=))\s*|(!*?[#~]?[\w$.^]+)([([])?)|(,\s*)|(\(?)\\?(?:(')|("))|(?:\s*(([)\]])(?=\s*[.^]|\s*$|[^\(\[])|[)\]])([([]?))|(\s+)/g, isRenderCall, rNewLine = /[ \t]*(\r\n|\n|\r)/g, rUnescapeQuotes = /\\(['"])/g, rEscapeQuotes = /['"\\]/g, rBuildHash = /(?:\x08|^)(onerror:)?(?:(~?)(([\w$_\.]+):)?([^\x08]+))\x08(,)?([^\x08]+)/gi, rTestElseIf = /^if\s/, rFirstElem = /<(\w+)[>\s]/, rAttrEncode = /[\x00`><"'&]/g, rIsHtml = /[\x00`><\"'&]/, rHasHandlers = /^on[A-Z]|^convert(Back)?$/, rHtmlEncode = rAttrEncode, autoTmplName = 0, viewId = 0, charEntities = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        "\x00": "&#0;",
        "'": "&#39;",
        '"': "&#34;",
        "`": "&#96;"
    }, HTML = "html", OBJECT = "object", tmplAttr = "data-jsv-tmpl", indexStr = "For #index in nested block use #getIndex().", $render = {}, jsvStores = {
        template: {compile: compileTmpl},
        tag: {compile: compileTag},
        helper: {},
        converter: {}
    }, $views = {
        jsviews: versionNumber,
        settings: function (settings) {
            $extend($viewsSettings, settings);
            dbgMode($viewsSettings._dbgMode);
            if ($viewsSettings.jsv) {
                $viewsSettings.jsv()
            }
        },
        sub: {
            View: View,
            Err: JsViewsError,
            tmplFn: tmplFn,
            parse: parseParams,
            extend: $extend,
            syntaxErr: syntaxError,
            onStore: {},
            _ths: tagHandlersFromProps,
            _tg: function () {
            }
        },
        map: dataMap,
        _cnvt: convertVal,
        _tag: renderTag,
        _err: error
    }, jsViewsPrev = global.jsviews;

    function getDerivedMethod(baseMethod, method) {
        return function () {
            var ret, tag = this, prevBase = tag.base;
            tag.base = baseMethod;
            ret = method.apply(tag, arguments);
            tag.base = prevBase;
            return ret
        }
    }

    function getMethod(baseMethod, method) {
        if ($isFunction(method)) {
            method = getDerivedMethod(!baseMethod ? noop : baseMethod._d ? baseMethod : getDerivedMethod(noop, baseMethod), method);
            method._d = 1
        }
        return method
    }

    function tagHandlersFromProps(tag, tagCtx) {
        for (var prop in tagCtx.props) {
            if (rHasHandlers.test(prop)) {
                tag[prop] = getMethod(tag[prop], tagCtx.props[prop])
            }
        }
    }

    function retVal(val) {
        return val
    }

    function noop() {
        return ""
    }

    function dbgBreak(val) {
        try {
            ;
            throw"dbg breakpoint"
        } catch (e) {
        }
        return this.base ? this.baseApply(arguments) : val
    }

    function dbgMode(debugMode) {
        $viewsSettings._dbgMode = debugMode !== false
    }

    function JsViewsError(message) {
        this.name = ($.link ? "JsViews" : "JsRender") + " Error";
        this.message = message || this.name
    }

    function $extend(target, source) {
        var name;
        for (name in source) {
            target[name] = source[name]
        }
        return target
    }

    (JsViewsError.prototype = new Error()).constructor = JsViewsError;
    function $viewsDelimiters(openChars, closeChars, link) {
        if (this !== 0 || openChars) {
            delimOpenChar0 = openChars ? openChars.charAt(0) : delimOpenChar0;
            delimOpenChar1 = openChars ? openChars.charAt(1) : delimOpenChar1;
            delimCloseChar0 = closeChars ? closeChars.charAt(0) : delimCloseChar0;
            delimCloseChar1 = closeChars ? closeChars.charAt(1) : delimCloseChar1;
            linkChar = link || linkChar;
            openChars = "\\" + delimOpenChar0 + "(\\" + linkChar + ")?\\" + delimOpenChar1;
            closeChars = "\\" + delimCloseChar0 + "\\" + delimCloseChar1;
            rTag = "(?:(?:(\\w+(?=[\\/\\s\\" + delimCloseChar0 + "]))|(?:(\\w+)?(:)|(>)|!--((?:[^-]|-(?!-))*)--|(\\*)))\\s*((?:[^\\" + delimCloseChar0 + "]|\\" + delimCloseChar0 + "(?!\\" + delimCloseChar1 + "))*?)";
            $sub.rTag = rTag + ")";
            rTag = new RegExp(openChars + rTag + "(\\/)?|(?:\\/(\\w+)))" + closeChars, "g");
            rTmplString = new RegExp("<.*>|([^\\\\]|^)[{}]|" + openChars + ".*" + closeChars)
        }
        return [delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, linkChar]
    }

    function getView(inner, type) {
        if (!type) {
            type = inner;
            inner = undefined
        }
        var views, i, l, found, view = this, root = !type || type === "root";
        if (inner) {
            found = view.type === type ? view : undefined;
            if (!found) {
                views = view.views;
                if (view._.useKey) {
                    for (i in views) {
                        if (found = views[i].get(inner, type)) {
                            break
                        }
                    }
                } else {
                    for (i = 0, l = views.length; !found && i < l; i++) {
                        found = views[i].get(inner, type)
                    }
                }
            }
        } else {
            if (root) {
                while (view.parent.parent) {
                    found = view = view.parent
                }
            } else {
                while (view && !found) {
                    found = view.type === type ? view : undefined;
                    view = view.parent
                }
            }
        }
        return found
    }

    function getNestedIndex() {
        var view = this.get("item");
        return view ? view.index : undefined
    }

    getNestedIndex.depends = function () {
        return [this.get("item"), "index"]
    };
    function getIndex() {
        return this.index
    }

    getIndex.depends = "index";
    function getHelper(helper) {
        var wrapped, view = this, ctx = view.linkCtx, res = (view.ctx || {})[helper];
        if (res === undefined && ctx && ctx.ctx) {
            res = ctx.ctx[helper]
        }
        if (res === undefined) {
            res = $helpers[helper]
        }
        if (res) {
            if ($isFunction(res) && !res._wrp) {
                wrapped = function () {
                    return res.apply((!this || this === global) ? view : this, arguments)
                };
                wrapped._wrp = true;
                $extend(wrapped, res)
            }
        }
        return wrapped || res
    }

    function convertVal(converter, view, tagCtx, onError) {
        var tag, value, boundTag = typeof tagCtx === "number" && view.tmpl.bnds[tagCtx - 1], linkCtx = view.linkCtx;
        if (onError !== undefined) {
            tagCtx = onError = {props: {}, args: [onError]}
        } else {
            if (boundTag) {
                tagCtx = boundTag(view.data, view, $views)
            }
        }
        value = tagCtx.args[0];
        if (converter || boundTag) {
            tag = linkCtx && linkCtx.tag;
            if (!tag) {
                tag = $extend(new $sub._tg(), {
                    _: {inline: !linkCtx, bnd: boundTag, unlinked: true},
                    tagName: ":",
                    cvt: converter,
                    flow: true,
                    tagCtx: tagCtx
                });
                if (linkCtx) {
                    linkCtx.tag = tag;
                    tag.linkCtx = linkCtx
                }
                tagCtx.ctx = extendCtx(tagCtx.ctx, (linkCtx ? linkCtx.view : view).ctx)
            }
            tag._er = onError && value;
            tagHandlersFromProps(tag, tagCtx);
            tagCtx.view = view;
            tag.ctx = tagCtx.ctx || {};
            tagCtx.ctx = undefined;
            view._.tag = tag;
            value = tag.cvtArgs(tag.convert || converter !== "true" && converter)[0];
            value = boundTag && view._.onRender ? view._.onRender(value, view, boundTag) : value;
            view._.tag = undefined
        }
        return value != undefined ? value : ""
    }

    function convertArgs(converter) {
        var tag = this, tagCtx = tag.tagCtx, view = tagCtx.view, args = tagCtx.args;
        converter = tag.convert || converter;
        converter = converter && ("" + converter === converter ? (view.getRsc("converters", converter) || error("Unknown converter: '" + converter + "'")) : converter);
        args = !args.length && !tagCtx.index ? [view.data] : converter ? args.slice() : args;
        if (converter) {
            if (converter.depends) {
                tag.depends = $sub.getDeps(tag.depends, tag, converter.depends, converter)
            }
            args[0] = converter.apply(tag, args)
        }
        return args
    }

    function getResource(resourceType, itemName) {
        var res, store, view = this;
        while ((res === undefined) && view) {
            store = view.tmpl && view.tmpl[resourceType];
            res = store && store[itemName];
            view = view.parent
        }
        return res || $views[resourceType][itemName]
    }

    function renderTag(tagName, parentView, tmpl, tagCtxs, isUpdate, onError) {
        parentView = parentView || topView;
        var tag, tag_, tagDef, template, tags, attr, parentTag, i, l, itemRet, tagCtx, tagCtxCtx, content, callInit, mapDef, thisMap, args, props, initialTmpl, ret = "", linkCtx = parentView.linkCtx || 0, ctx = parentView.ctx, parentTmpl = tmpl || parentView.tmpl, boundTag = typeof tagCtxs === "number" && parentView.tmpl.bnds[tagCtxs - 1];
        if (tagName._is === "tag") {
            tag = tagName;
            tagName = tag.tagName;
            tagCtxs = tag.tagCtxs;
            template = tag.template
        } else {
            tagDef = parentView.getRsc("tags", tagName) || error("Unknown tag: {{" + tagName + "}} ");
            template = tagDef.template
        }
        if (onError !== undefined) {
            ret += onError;
            tagCtxs = onError = [{props: {}, args: []}]
        } else {
            if (boundTag) {
                tagCtxs = boundTag(parentView.data, parentView, $views)
            }
        }
        l = tagCtxs.length;
        for (i = 0; i < l; i++) {
            tagCtx = tagCtxs[i];
            if (!linkCtx || !linkCtx.tag || i && !linkCtx.tag._.inline || tag._er) {
                if (content = tagCtx.tmpl) {
                    content = tagCtx.content = parentTmpl.tmpls[content - 1]
                }
                tagCtx.index = i;
                tagCtx.tmpl = template || content;
                tagCtx.render = renderContent;
                tagCtx.view = parentView;
                tagCtx.ctx = extendCtx(tagCtx.ctx, ctx)
            }
            if (tmpl = tagCtx.props.tmpl) {
                tmpl = "" + tmpl === tmpl ? parentView.getRsc("templates", tmpl) || $templates(tmpl) : tmpl;
                tagCtx.tmpl = tmpl
            }
            if (!tag) {
                tag = new tagDef._ctr();
                callInit = !!tag.init;
                tag.parent = parentTag = ctx && ctx.tag;
                tag.tagCtxs = tagCtxs;
                if (linkCtx) {
                    tag._.inline = false;
                    linkCtx.tag = tag;
                    tag.linkCtx = linkCtx
                }
                if (tag._.bnd = boundTag || linkCtx.fn) {
                    tag._.arrVws = {}
                } else {
                    if (tag.dataBoundOnly) {
                        error("{^{" + tagName + "}} tag must be data-bound")
                    }
                }
            }
            tagCtx.tag = tag;
            if (tag.dataMap && tag.tagCtxs) {
                tagCtx.map = tag.tagCtxs[i].map
            }
            if (!tag.flow) {
                tagCtxCtx = tagCtx.ctx = tagCtx.ctx || {};
                tags = tag.parents = tagCtxCtx.parentTags = ctx && extendCtx(tagCtxCtx.parentTags, ctx.parentTags) || {};
                if (parentTag) {
                    tags[parentTag.tagName] = parentTag
                }
                tags[tag.tagName] = tagCtxCtx.tag = tag
            }
        }
        if (boundTag || linkCtx) {
            parentView._.tag = tag
        }
        if (!(tag._er = onError)) {
            tagHandlersFromProps(tag, tagCtxs[0]);
            tag.rendering = {};
            for (i = 0; i < l; i++) {
                tagCtx = tag.tagCtx = tag.tagCtxs[i];
                props = tagCtx.props;
                args = tag.cvtArgs();
                if (mapDef = props.dataMap || tag.dataMap) {
                    if (args.length || props.dataMap) {
                        thisMap = tagCtx.map;
                        if (!thisMap || thisMap.src !== args[0] || isUpdate) {
                            if (thisMap && thisMap.src) {
                                thisMap.unmap()
                            }
                            thisMap = tagCtx.map = mapDef.map(args[0], props)
                        }
                        args = [thisMap.tgt]
                    }
                }
                tag.ctx = tagCtx.ctx;
                if (!i) {
                    if (callInit) {
                        initialTmpl = tag.template;
                        tag.init(tagCtx, linkCtx, tag.ctx);
                        callInit = undefined;
                        if (tag.template !== initialTmpl) {
                            tag._.tmpl = tag.template
                        }
                    }
                    if (linkCtx) {
                        linkCtx.attr = tag.attr = linkCtx.attr || tag.attr
                    }
                    attr = tag.attr;
                    tag._.noVws = attr && attr !== HTML
                }
                itemRet = undefined;
                if (tag.render) {
                    itemRet = tag.render.apply(tag, args)
                }
                if (!args.length) {
                    args = [parentView]
                }
                if (itemRet === undefined) {
                    itemRet = tagCtx.render(args.length ? args[0] : parentView, true) || (isUpdate ? undefined : "")
                }
                ret = ret ? ret + (itemRet || "") : itemRet
            }
            tag.rendering = undefined
        }
        tag.tagCtx = tag.tagCtxs[0];
        tag.ctx = tag.tagCtx.ctx;
        if (tag._.noVws) {
            if (tag._.inline) {
                ret = attr === "text" ? $converters.html(ret) : ""
            }
        }
        return boundTag && parentView._.onRender ? parentView._.onRender(ret, parentView, boundTag) : ret
    }

    function View(context, type, parentView, data, template, key, contentTmpl, onRender) {
        var views, parentView_, tag, self_, self = this, isArray = type === "array";
        self.content = contentTmpl;
        self.views = isArray ? [] : {};
        self.parent = parentView;
        self.type = type || "top";
        self.data = data;
        self.tmpl = template;
        self_ = self._ = {key: 0, useKey: isArray ? 0 : 1, id: "" + viewId++, onRender: onRender, bnds: {}};
        self.linked = !!onRender;
        if (parentView) {
            views = parentView.views;
            parentView_ = parentView._;
            if (parentView_.useKey) {
                views[self_.key = "_" + parentView_.useKey++] = self;
                self.index = indexStr;
                self.getIndex = getNestedIndex;
                tag = parentView_.tag;
                self_.bnd = isArray && (!tag || !!tag._.bnd && tag)
            } else {
                if (views.length === (self_.key = self.index = key)) {
                    views.push(self)
                } else {
                    views.splice(key, 0, self)
                }
            }
            self.ctx = context || parentView.ctx
        } else {
            self.ctx = context
        }
    }

    View.prototype = {get: getView, getIndex: getIndex, getRsc: getResource, hlp: getHelper, _is: "view"};
    function compileChildResources(parentTmpl) {
        var storeName, resources, resourceName, resource, settings, compile, onStore;
        for (storeName in jsvStores) {
            settings = jsvStores[storeName];
            if ((compile = settings.compile) && (resources = parentTmpl[storeName + "s"])) {
                for (resourceName in resources) {
                    resource = resources[resourceName] = compile(resourceName, resources[resourceName], parentTmpl, 0);
                    resource._is = storeName;
                    if (resource && (onStore = $sub.onStore[storeName])) {
                        onStore(resourceName, resource, compile)
                    }
                }
            }
        }
    }

    function compileTag(name, tagDef, parentTmpl) {
        var tmpl, baseTag, prop, compiledDef = new $sub._tg();

        function Tag() {
            var tag = this;
            tag._ = {inline: true, unlinked: true};
            tag.tagName = name
        }

        if ($isFunction(tagDef)) {
            tagDef = {depends: tagDef.depends, render: tagDef}
        } else {
            if ("" + tagDef === tagDef) {
                tagDef = {template: tagDef}
            }
        }
        if (baseTag = tagDef.baseTag) {
            tagDef.flow = !!tagDef.flow;
            tagDef.baseTag = baseTag = "" + baseTag === baseTag ? (parentTmpl && parentTmpl.tags[baseTag] || $tags[baseTag]) : baseTag;
            compiledDef = $extend(compiledDef, baseTag);
            for (prop in tagDef) {
                compiledDef[prop] = getMethod(baseTag[prop], tagDef[prop])
            }
        } else {
            compiledDef = $extend(compiledDef, tagDef)
        }
        if ((tmpl = compiledDef.template) !== undefined) {
            compiledDef.template = "" + tmpl === tmpl ? ($templates[tmpl] || $templates(tmpl)) : tmpl
        }
        if (compiledDef.init !== false) {
            (Tag.prototype = compiledDef).constructor = compiledDef._ctr = Tag
        }
        if (parentTmpl) {
            compiledDef._parentTmpl = parentTmpl
        }
        return compiledDef
    }

    function baseApply(args) {
        return this.base.apply(this, args)
    }

    function compileTmpl(name, tmpl, parentTmpl, options) {
        function lookupTemplate(value) {
            var currentName;
            if (("" + value === value) || value.nodeType > 0 && (elem = value)) {
                if (!elem) {
                    if (value.charAt(0) === "@") {
                        if (fs) {
                            value = $templates[name = name || (value = fs.realpathSync(value.slice(1)))] = $templates[name] || compileTmpl(name, fs.readFileSync(value, "utf8"), parentTmpl, options)
                        } else {
                            elem = document.getElementById(value)
                        }
                    } else {
                        if ($.fn && !rTmplString.test(value)) {
                            try {
                                elem = $(document).find(value)[0]
                            } catch (e) {
                            }
                        }
                    }
                }
                if (elem) {
                    if (options) {
                        value = elem.innerHTML
                    } else {
                        if ((currentName = elem.getAttribute(tmplAttr)) && (value = $templates[currentName]) && name !== currentName) {
                            delete $templates[currentName]
                        }
                        name = name || currentName || "_" + autoTmplName++;
                        if (!currentName) {
                            value = compileTmpl(name, elem.innerHTML, parentTmpl, options)
                        }
                        elem.setAttribute(tmplAttr, name);
                        $templates[value.tmplName = name] = value
                    }
                    elem = undefined
                }
            } else {
                if (!value.fn) {
                    value = undefined
                }
            }
            return value
        }

        var elem, compiledTmpl, tmplOrMarkup = tmpl = tmpl || "";
        if (options === 0) {
            options = undefined;
            tmplOrMarkup = lookupTemplate(tmplOrMarkup)
        }
        options = options || (tmpl.markup ? tmpl : {});
        options.tmplName = name;
        if (parentTmpl) {
            options._parentTmpl = parentTmpl
        }
        if (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = lookupTemplate(tmpl.markup))) {
            if (tmplOrMarkup.fn) {
                tmplOrMarkup = tmplOrMarkup.markup
            }
        }
        if (tmplOrMarkup !== undefined) {
            if (tmplOrMarkup.fn || tmpl.fn) {
                if (tmplOrMarkup.fn) {
                    compiledTmpl = tmplOrMarkup
                }
            } else {
                tmpl = tmplObject(tmplOrMarkup, options);
                tmplFn(tmplOrMarkup.replace(rEscapeQuotes, "\\$&"), tmpl)
            }
            if (!compiledTmpl) {
                compileChildResources(options);
                compiledTmpl = $extend(function () {
                    return tmpl.render.apply(tmpl, arguments)
                }, tmpl)
            }
            if (name && !parentTmpl) {
                $render[name] = compiledTmpl
            }
            return compiledTmpl
        }
    }

    function dataMap(mapDef) {
        function Map(source, options) {
            this.tgt = mapDef.getTgt(source, options)
        }

        if ($isFunction(mapDef)) {
            mapDef = {getTgt: mapDef}
        }
        if (mapDef.baseMap) {
            mapDef = $extend($extend({}, mapDef.baseMap), mapDef)
        }
        mapDef.map = function (source, options) {
            return new Map(source, options)
        };
        return mapDef
    }

    function tmplObject(markup, options) {
        var htmlTag, wrapMap = $viewsSettings.wrapMap || {}, tmpl = $extend({
            tmpls: [],
            links: {},
            bnds: [],
            _is: "template",
            render: renderContent
        }, options);
        tmpl.markup = markup;
        if (!options.htmlTag) {
            htmlTag = rFirstElem.exec(markup);
            tmpl.htmlTag = htmlTag ? htmlTag[1].toLowerCase() : ""
        }
        htmlTag = wrapMap[tmpl.htmlTag];
        if (htmlTag && htmlTag !== wrapMap.div) {
            tmpl.markup = $.trim(tmpl.markup)
        }
        return tmpl
    }

    function registerStore(storeName, storeSettings) {
        function theStore(name, item, parentTmpl) {
            var onStore, compile, itemName, thisStore;
            if (name && typeof name === OBJECT && !name.nodeType && !name.markup && !name.getTgt) {
                for (itemName in name) {
                    theStore(itemName, name[itemName], item)
                }
                return $views
            }
            if (item === undefined) {
                item = name;
                name = undefined
            }
            if (name && "" + name !== name) {
                parentTmpl = item;
                item = name;
                name = undefined
            }
            thisStore = parentTmpl ? parentTmpl[storeNames] = parentTmpl[storeNames] || {} : theStore;
            compile = storeSettings.compile;
            if (item === null) {
                if (name) {
                    delete thisStore[name]
                }
            } else {
                item = compile ? compile(name, item, parentTmpl, 0) : item;
                if (name) {
                    thisStore[name] = item
                }
            }
            if (compile && item) {
                item._is = storeName
            }
            if (item && (onStore = $sub.onStore[storeName])) {
                onStore(name, item, compile)
            }
            return item
        }

        var storeNames = storeName + "s";
        $views[storeNames] = theStore
    }

    function renderContent(data, context, noIteration, parentView, key, onRender) {
        var i, l, tag, tmpl, tagCtx, isTopRenderCall, prevData, prevIndex, view = parentView, result = "";
        if (context === true) {
            noIteration = context;
            context = undefined
        } else {
            if (typeof context !== OBJECT) {
                context = undefined
            }
        }
        if (tag = this.tag) {
            tagCtx = this;
            tmpl = tag._.tmpl || tagCtx.tmpl;
            view = view || tagCtx.view;
            if (!arguments.length) {
                data = view
            }
        } else {
            tmpl = this
        }
        if (tmpl) {
            if (!view && data && data._is === "view") {
                view = data
            }
            if (view) {
                if (data === view) {
                    data = view.data
                }
            }
            if (!tmpl.fn) {
                tmpl = tag._.tmpl = $templates[tmpl] || $templates(tmpl)
            }
            isRenderCall = isRenderCall || (isTopRenderCall = !view);
            if (!view) {
                (context = context || {}).root = data
            }
            if (!isRenderCall || tmpl.useViews) {
                result = renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag)
            } else {
                if (view) {
                    prevData = view.data;
                    prevIndex = view.index;
                    view.index = indexStr
                } else {
                    view = topView;
                    view.data = data;
                    view.ctx = context
                }
                if ($isArray(data) && !noIteration) {
                    for (i = 0, l = data.length; i < l; i++) {
                        view.index = i;
                        view.data = data[i];
                        result += tmpl.fn(data[i], view, $views)
                    }
                } else {
                    result += tmpl.fn(data, view, $views)
                }
                view.data = prevData;
                view.index = prevIndex
            }
            if (isTopRenderCall) {
                isRenderCall = undefined
            }
        }
        return result
    }

    function renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag) {
        function setItemVar(item) {
            newCtx = $extend({}, context);
            newCtx[itemVar] = item
        }

        var i, l, newView, childView, itemResult, swapContent, contentTmpl, outerOnRender, tmplName, itemVar, newCtx, tagCtx, result = "";
        if (tag) {
            tmplName = tag.tagName;
            tagCtx = tag.tagCtx;
            context = context ? extendCtx(context, tag.ctx) : tag.ctx;
            contentTmpl = tagCtx.content;
            if (tagCtx.props.link === false) {
                context = context || {};
                context.link = false
            }
            if (itemVar = tagCtx.props.itemVar) {
                if (itemVar.charAt(0) !== "~") {
                    syntaxError("Use itemVar='~myItem'")
                }
                itemVar = itemVar.slice(1)
            }
        }
        if (view) {
            contentTmpl = contentTmpl || view.content;
            onRender = onRender || view._.onRender;
            context = context || view.ctx
        }
        if (key === true) {
            swapContent = true;
            key = 0
        }
        if (onRender && (context && context.link === false || tag && tag._.noVws)) {
            onRender = undefined
        }
        outerOnRender = onRender;
        if (onRender === true) {
            outerOnRender = undefined;
            onRender = view._.onRender
        }
        context = tmpl.helpers ? extendCtx(tmpl.helpers, context) : context;
        newCtx = context;
        if ($isArray(data) && !noIteration) {
            newView = swapContent ? view : (key !== undefined && view) || new View(context, "array", view, data, tmpl, key, contentTmpl, onRender);
            if (itemVar) {
                newView.it = itemVar
            }
            itemVar = newView.it;
            for (i = 0, l = data.length; i < l; i++) {
                if (itemVar) {
                    setItemVar(data[i])
                }
                childView = new View(newCtx, "item", newView, data[i], tmpl, (key || 0) + i, contentTmpl, onRender);
                itemResult = tmpl.fn(data[i], childView, $views);
                result += newView._.onRender ? newView._.onRender(itemResult, childView) : itemResult
            }
        } else {
            if (itemVar) {
                setItemVar(data)
            }
            newView = swapContent ? view : new View(newCtx, tmplName || "data", view, data, tmpl, key, contentTmpl, onRender);
            if (tag && !tag.flow) {
                newView.tag = tag
            }
            result += tmpl.fn(data, newView, $views)
        }
        return outerOnRender ? outerOnRender(result, newView) : result
    }

    function error(e, view, fallback) {
        var message = $viewsSettings.onError(e, view, fallback);
        if ("" + e === e) {
            throw new $sub.Err(message)
        }
        return !view.linkCtx && view.linked ? $converters.html(message) : message
    }

    function syntaxError(message) {
        error("Syntax error\n" + message)
    }

    function tmplFn(markup, tmpl, isLinkExpr, convertBack, hasElse) {
        function pushprecedingContent(shift) {
            shift -= loc;
            if (shift) {
                content.push(markup.substr(loc, shift).replace(rNewLine, "\\n"))
            }
        }

        function blockTagCheck(tagName, block) {
            if (tagName) {
                tagName += "}}";
                syntaxError((block ? "{{" + block + "}} block has {{/" + tagName + " without {{" + tagName : "Unmatched or missing {{/" + tagName) + ", in template:\n" + markup)
            }
        }

        function parseTag(all, bind, tagName, converter, colon, html, comment, codeTag, params, slash, closeBlock, index) {
            if (html) {
                colon = ":";
                converter = HTML
            }
            slash = slash || isLinkExpr && !hasElse;
            var pathBindings = (bind || isLinkExpr) && [[]], props = "", args = "", ctxProps = "", paramsArgs = "", paramsProps = "", paramsCtxProps = "", onError = "", useTrigger = "", block = !slash && !colon && !comment;
            tagName = tagName || (params = params || "#data", colon);
            pushprecedingContent(index);
            loc = index + all.length;
            if (codeTag) {
                if (allowCode) {
                    content.push(["*", "\n" + params.replace(/^:/, "ret+= ").replace(rUnescapeQuotes, "$1") + ";\n"])
                }
            } else {
                if (tagName) {
                    if (tagName === "else") {
                        if (rTestElseIf.test(params)) {
                            syntaxError('for "{{else if expr}}" use "{{else expr}}"')
                        }
                        pathBindings = current[7] && [[]];
                        current[8] = markup.substring(current[8], index);
                        current = stack.pop();
                        content = current[2];
                        block = true
                    }
                    if (params) {
                        parseParams(params.replace(rNewLine, " "), pathBindings, tmpl).replace(rBuildHash, function (all, onerror, isCtx, key, keyToken, keyValue, arg, param) {
                            key = "'" + keyToken + "':";
                            if (arg) {
                                args += keyValue + ",";
                                paramsArgs += "'" + param + "',"
                            } else {
                                if (isCtx) {
                                    ctxProps += key + keyValue + ",";
                                    paramsCtxProps += key + "'" + param + "',"
                                } else {
                                    if (onerror) {
                                        onError += keyValue
                                    } else {
                                        if (keyToken === "trigger") {
                                            useTrigger += keyValue
                                        }
                                        props += key + keyValue + ",";
                                        paramsProps += key + "'" + param + "',";
                                        hasHandlers = hasHandlers || rHasHandlers.test(keyToken)
                                    }
                                }
                            }
                            return ""
                        }).slice(0, -1)
                    }
                    if (pathBindings && pathBindings[0]) {
                        pathBindings.pop()
                    }
                    newNode = [tagName, converter || !!convertBack || hasHandlers || "", block && [], parsedParam(paramsArgs, paramsProps, paramsCtxProps), parsedParam(args, props, ctxProps), onError, useTrigger, pathBindings || 0];
                    content.push(newNode);
                    if (block) {
                        stack.push(current);
                        current = newNode;
                        current[8] = loc
                    }
                } else {
                    if (closeBlock) {
                        blockTagCheck(closeBlock !== current[0] && current[0] !== "else" && closeBlock, current[0]);
                        current[8] = markup.substring(current[8], index);
                        current = stack.pop()
                    }
                }
            }
            blockTagCheck(!current && closeBlock);
            content = current[2]
        }

        var result, newNode, hasHandlers, allowCode = $viewsSettings.allowCode || tmpl && tmpl.allowCode, astTop = [], loc = 0, stack = [], content = astTop, current = [, , astTop];
        if (allowCode) {
            tmpl.allowCode = allowCode
        }
        if (isLinkExpr) {
            markup = delimOpenChar0 + markup + delimCloseChar1
        }
        blockTagCheck(stack[0] && stack[0][2].pop()[0]);
        markup.replace(rTag, parseTag);
        pushprecedingContent(markup.length);
        if (loc = astTop[astTop.length - 1]) {
            blockTagCheck("" + loc !== loc && (+loc[8] === loc[8]) && loc[0])
        }
        if (isLinkExpr) {
            result = buildCode(astTop, markup, isLinkExpr);
            setPaths(result, [astTop[0][7]])
        } else {
            result = buildCode(astTop, tmpl)
        }
        return result
    }

    function setPaths(fn, pathsArr) {
        var key, paths, i = 0, l = pathsArr.length;
        fn.deps = [];
        for (; i < l; i++) {
            paths = pathsArr[i];
            for (key in paths) {
                if (key !== "_jsvto" && paths[key].length) {
                    fn.deps = fn.deps.concat(paths[key])
                }
            }
        }
        fn.paths = paths
    }

    function parsedParam(args, props, ctx) {
        return [args.slice(0, -1), props.slice(0, -1), ctx.slice(0, -1)]
    }

    function paramStructure(parts, type) {
        return "\n\t" + (type ? type + ":{" : "") + "args:[" + parts[0] + "]" + (parts[1] || !type ? ",\n\tprops:{" + parts[1] + "}" : "") + (parts[2] ? ",\n\tctx:{" + parts[2] + "}" : "")
    }

    function parseParams(params, pathBindings, tmpl) {
        function parseTokens(all, lftPrn0, lftPrn, bound, path, operator, err, eq, path2, prn, comma, lftPrn2, apos, quot, rtPrn, rtPrnDot, prn2, space, index, full) {
            bound = bindings && bound;
            if (bound && !eq) {
                path = bound + path
            }
            operator = operator || "";
            lftPrn = lftPrn || lftPrn0 || lftPrn2;
            path = path || path2;
            prn = prn || prn2 || "";
            var expr, exprFn, binds, theOb, newOb;

            function parsePath(allPath, not, object, helper, view, viewProperty, pathTokens, leafToken) {
                var subPath = object === ".";
                if (object) {
                    path = path.slice(not.length);
                    if (!subPath) {
                        allPath = (helper ? 'view.hlp("' + helper + '")' : view ? "view" : "data") + (leafToken ? (viewProperty ? "." + viewProperty : helper ? "" : (view ? "" : "." + object)) + (pathTokens || "") : (leafToken = helper ? "" : view ? viewProperty || "" : object, ""));
                        allPath = allPath + (leafToken ? "." + leafToken : "");
                        allPath = not + (allPath.slice(0, 9) === "view.data" ? allPath.slice(5) : allPath)
                    }
                    if (bindings) {
                        binds = named === "linkTo" ? (bindto = pathBindings._jsvto = pathBindings._jsvto || []) : bndCtx.bd;
                        if (theOb = subPath && binds[binds.length - 1]) {
                            if (theOb._jsv) {
                                while (theOb.sb) {
                                    theOb = theOb.sb
                                }
                                if (theOb.bnd) {
                                    path = "^" + path.slice(1)
                                }
                                theOb.sb = path;
                                theOb.bnd = theOb.bnd || path.charAt(0) === "^"
                            }
                        } else {
                            binds.push(path)
                        }
                        pathStart[parenDepth] = index + (subPath ? 1 : 0)
                    }
                }
                return allPath
            }

            if (err && !aposed && !quoted) {
                syntaxError(params)
            } else {
                if (bindings && rtPrnDot && !aposed && !quoted) {
                    if (!named || boundName || bindto) {
                        expr = pathStart[parenDepth - 1];
                        if (full.length - 1 > index - (expr || 0)) {
                            expr = full.slice(expr, index + all.length);
                            if (exprFn !== true) {
                                binds = bindto || bndStack[parenDepth - 1].bd;
                                theOb = binds[binds.length - 1];
                                if (theOb && theOb.prm) {
                                    while (theOb.sb && theOb.sb.prm) {
                                        theOb = theOb.sb
                                    }
                                    newOb = theOb.sb = {path: theOb.sb, bnd: theOb.bnd}
                                } else {
                                    binds.push(newOb = {path: binds.pop()})
                                }
                            }
                            rtPrnDot = delimOpenChar1 + ":" + expr + " onerror=''" + delimCloseChar0;
                            exprFn = tmplLinks[rtPrnDot];
                            if (!exprFn) {
                                tmplLinks[rtPrnDot] = true;
                                tmplLinks[rtPrnDot] = exprFn = tmplFn(rtPrnDot, tmpl, true)
                            }
                            if (exprFn !== true && newOb) {
                                newOb._jsv = exprFn;
                                newOb.prm = bndCtx.bd;
                                newOb.bnd = newOb.bnd || newOb.path && newOb.path.indexOf("^") >= 0
                            }
                        }
                    }
                }
                return (aposed ? (aposed = !apos, (aposed ? all : lftPrn2 + '"')) : quoted ? (quoted = !quot, (quoted ? all : lftPrn2 + '"')) : ((lftPrn ? (pathStart[parenDepth] = index++, bndCtx = bndStack[++parenDepth] = {bd: []}, lftPrn) : "") + (space ? (parenDepth ? "" : (paramIndex = full.slice(paramIndex, index), named ? (named = boundName = bindto = false, "\b") : "\b,") + paramIndex + (paramIndex = index + all.length, bindings && pathBindings.push(bndCtx.bd = []), "\b")) : eq ? (parenDepth && syntaxError(params), bindings && pathBindings.pop(), named = path, boundName = bound, paramIndex = index + all.length, bound && (bindings = bndCtx.bd = pathBindings[named] = []), path + ":") : path ? (path.split("^").join(".").replace(rPath, parsePath) + (prn ? (bndCtx = bndStack[++parenDepth] = {bd: []}, fnCall[parenDepth] = true, prn) : operator)) : operator ? operator : rtPrn ? ((fnCall[parenDepth] = false, bndCtx = bndStack[--parenDepth], rtPrn) + (prn ? (bndCtx = bndStack[++parenDepth], fnCall[parenDepth] = true, prn) : "")) : comma ? (fnCall[parenDepth] || syntaxError(params), ",") : lftPrn0 ? "" : (aposed = apos, quoted = quot, '"'))))
            }
        }

        var named, bindto, boundName, quoted, aposed, bindings = pathBindings && pathBindings[0], bndCtx = {bd: bindings}, bndStack = {0: bndCtx}, paramIndex = 0, tmplLinks = tmpl ? tmpl.links : bindings && (bindings.links = bindings.links || {}), parenDepth = 0, fnCall = {}, pathStart = {};
        return (params + (tmpl ? " " : "")).replace(rParams, parseTokens)
    }

    function buildCode(ast, tmpl, isLinkExpr) {
        var i, node, tagName, converter, tagCtx, hasTag, hasEncoder, getsVal, hasCnvt, useCnvt, tmplBindings, pathBindings, params, boundOnErrStart, boundOnErrEnd, tagRender, nestedTmpls, tmplName, nestedTmpl, tagAndElses, content, markup, nextIsElse, oldCode, isElse, isGetVal, tagCtxFn, onError, tagStart, trigger, tmplBindingKey = 0, useViews = tmpl.useViews || tmpl.tags || tmpl.templates || tmpl.helpers || tmpl.converters, code = "", tmplOptions = {}, l = ast.length;
        if ("" + tmpl === tmpl) {
            tmplName = isLinkExpr ? 'data-link="' + tmpl.replace(rNewLine, " ").slice(1, -1) + '"' : tmpl;
            tmpl = 0
        } else {
            tmplName = tmpl.tmplName || "unnamed";
            if (tmpl.allowCode) {
                tmplOptions.allowCode = true
            }
            if (tmpl.debug) {
                tmplOptions.debug = true
            }
            tmplBindings = tmpl.bnds;
            nestedTmpls = tmpl.tmpls
        }
        for (i = 0; i < l; i++) {
            node = ast[i];
            if ("" + node === node) {
                code += '\n+"' + node + '"'
            } else {
                tagName = node[0];
                if (tagName === "*") {
                    code += ";\n" + node[1] + "\nret=ret"
                } else {
                    converter = node[1];
                    content = !isLinkExpr && node[2];
                    tagCtx = paramStructure(node[3], "params") + "}," + paramStructure(params = node[4]);
                    onError = node[5];
                    trigger = node[6];
                    markup = node[8] && node[8].replace(rUnescapeQuotes, "$1");
                    if (isElse = tagName === "else") {
                        if (pathBindings) {
                            pathBindings.push(node[7])
                        }
                    } else {
                        tmplBindingKey = 0;
                        if (tmplBindings && (pathBindings = node[7])) {
                            pathBindings = [pathBindings];
                            tmplBindingKey = tmplBindings.push(1)
                        }
                    }
                    useViews = useViews || params[1] || params[2] || pathBindings || /view.(?!index)/.test(params[0]);
                    if (isGetVal = tagName === ":") {
                        if (converter) {
                            tagName = converter === HTML ? ">" : converter + tagName
                        }
                    } else {
                        if (content) {
                            nestedTmpl = tmplObject(markup, tmplOptions);
                            nestedTmpl.tmplName = tmplName + "/" + tagName;
                            nestedTmpl.useViews = nestedTmpl.useViews || useViews;
                            buildCode(content, nestedTmpl);
                            useViews = nestedTmpl.useViews;
                            nestedTmpls.push(nestedTmpl)
                        }
                        if (!isElse) {
                            tagAndElses = tagName;
                            useViews = useViews || tagName && (!$tags[tagName] || !$tags[tagName].flow);
                            oldCode = code;
                            code = ""
                        }
                        nextIsElse = ast[i + 1];
                        nextIsElse = nextIsElse && nextIsElse[0] === "else"
                    }
                    tagStart = onError ? ";\ntry{\nret+=" : "\n+";
                    boundOnErrStart = "";
                    boundOnErrEnd = "";
                    if (isGetVal && (pathBindings || trigger || converter && converter !== HTML)) {
                        tagCtxFn = "return {" + tagCtx + "};";
                        tagRender = 'c("' + converter + '",view,';
                        tagCtxFn = new Function("data,view,j,u", " // " + tmplName + " " + tmplBindingKey + " " + tagName + "\n" + tagCtxFn);
                        tagCtxFn._er = onError;
                        boundOnErrStart = tagRender + tmplBindingKey + ",";
                        boundOnErrEnd = ")";
                        tagCtxFn._tag = tagName;
                        if (isLinkExpr) {
                            return tagCtxFn
                        }
                        setPaths(tagCtxFn, pathBindings);
                        useCnvt = true
                    }
                    code += (isGetVal ? (isLinkExpr ? (onError ? "\ntry{\n" : "") + "return " : tagStart) + (useCnvt ? (useCnvt = undefined, useViews = hasCnvt = true, tagRender + (pathBindings ? ((tmplBindings[tmplBindingKey - 1] = tagCtxFn), tmplBindingKey) : "{" + tagCtx + "}") + ")") : tagName === ">" ? (hasEncoder = true, "h(" + params[0] + ")") : (getsVal = true, "((v=" + (params[0] || "data") + ')!=null?v:"")')) : (hasTag = true, "\n{view:view,tmpl:" + (content ? nestedTmpls.length : "0") + "," + tagCtx + "},"));
                    if (tagAndElses && !nextIsElse) {
                        code = "[" + code.slice(0, -1) + "]";
                        tagRender = 't("' + tagAndElses + '",view,this,';
                        if (isLinkExpr || pathBindings) {
                            code = new Function("data,view,j,u", " // " + tmplName + " " + tmplBindingKey + " " + tagAndElses + "\nreturn " + code + ";");
                            code._er = onError;
                            code._tag = tagAndElses;
                            if (pathBindings) {
                                setPaths(tmplBindings[tmplBindingKey - 1] = code, pathBindings)
                            }
                            if (isLinkExpr) {
                                return code
                            }
                            boundOnErrStart = tagRender + tmplBindingKey + ",undefined,";
                            boundOnErrEnd = ")"
                        }
                        code = oldCode + tagStart + tagRender + (tmplBindingKey || code) + ")";
                        pathBindings = 0;
                        tagAndElses = 0
                    }
                    if (onError) {
                        useViews = true;
                        code += ";\n}catch(e){ret" + (isLinkExpr ? "urn " : "+=") + boundOnErrStart + "j._err(e,view," + onError + ")" + boundOnErrEnd + ";}\n" + (isLinkExpr ? "" : "ret=ret")
                    }
                }
            }
        }
        code = "// " + tmplName + "\nvar v" + (hasTag ? ",t=j._tag" : "") + (hasCnvt ? ",c=j._cnvt" : "") + (hasEncoder ? ",h=j.converters.html" : "") + (isLinkExpr ? ";\n" : ',ret=""\n') + (tmplOptions.debug ? "debugger;" : "") + code + (isLinkExpr ? "\n" : ";\nreturn ret;");
        if ($viewsSettings._dbgMode) {
            code = "try {\n" + code + "\n}catch(e){\nreturn j._err(e, view);\n}"
        }
        try {
            code = new Function("data,view,j,u", code)
        } catch (e) {
            syntaxError("Compiled template code:\n\n" + code + '\n: "' + e.message + '"')
        }
        if (tmpl) {
            tmpl.fn = code;
            tmpl.useViews = !!useViews
        }
        return code
    }

    function extendCtx(context, parentContext) {
        return context && context !== parentContext ? (parentContext ? $extend($extend({}, parentContext), context) : context) : parentContext && $extend({}, parentContext)
    }

    function getCharEntity(ch) {
        return charEntities[ch] || (charEntities[ch] = "&#" + ch.charCodeAt(0) + ";")
    }

    for (jsvStoreName in jsvStores) {
        registerStore(jsvStoreName, jsvStores[jsvStoreName])
    }
    var $isFunction, $isArray, $templates = $views.templates, $converters = $views.converters, $helpers = $views.helpers, $tags = $views.tags, $sub = $views.sub, $viewsSettings = $views.settings;
    $sub._tg.prototype = {baseApply: baseApply, cvtArgs: convertArgs};
    topView = $sub.topView = new View();
    if ($) {
        $.fn.render = function (data, context, noIteration) {
            var tmplElem = this.jquery && (this[0] || error('Unknown template: "' + this.selector + '"')), tmpl = tmplElem.getAttribute(tmplAttr);
            return renderContent.call(tmpl ? $templates[tmpl] : $templates(tmplElem), data, context, noIteration)
        };
        if ($.observable) {
            $extend($sub, $.views.sub);
            $views.map = $.views.map
        }
    } else {
        $ = {};
        if (!isCommonJS) {
            global.jsviews = $
        }
        $.isFunction = function (ob) {
            return typeof ob === "function"
        };
        $.isArray = Array.isArray || function (obj) {
                return $.toString.call(obj) === "[object Array]"
            };
        $.noConflict = function () {
            if (global.jsviews === $) {
                global.jsviews = jsViewsPrev
            }
            return $
        }
    }
    $isFunction = $.isFunction;
    $isArray = $.isArray;
    $.render = $render;
    $.views = $views;
    $.templates = $templates = $views.templates;
    $views.compile = function (markup, options) {
        options = options || {};
        options.markup = markup;
        return $templates(options)
    };
    $viewsSettings({
        debugMode: dbgMode, delimiters: $viewsDelimiters, onError: function (e, view, fallback) {
            if (view) {
                e = fallback === undefined ? "{Error: " + (e.message || e) + "}" : $isFunction(fallback) ? fallback(e, view) : fallback
            }
            return e == undefined ? "" : e
        }, _dbgMode: false
    });
    $tags({
        "if": {
            render: function (val) {
                var self = this, tagCtx = self.tagCtx, ret = (self.rendering.done || !val && (arguments.length || !tagCtx.index)) ? "" : (self.rendering.done = true, self.selected = tagCtx.index, tagCtx.render(tagCtx.view, true));
                return ret
            }, flow: true
        },
        "for": {
            render: function (val) {
                var finalElse = !arguments.length, value, self = this, tagCtx = self.tagCtx, result = "", done = 0;
                if (!self.rendering.done) {
                    value = finalElse ? tagCtx.view.data : val;
                    if (value !== undefined) {
                        result += tagCtx.render(value, finalElse);
                        done += $isArray(value) ? value.length : 1
                    }
                    if (self.rendering.done = done) {
                        self.selected = tagCtx.index
                    }
                }
                return result
            }, flow: true
        },
        props: {baseTag: "for", dataMap: dataMap(getTargetProps), flow: true},
        include: {flow: true},
        "*": {render: retVal, flow: true},
        ":*": {render: retVal, flow: true},
        dbg: $helpers.dbg = $converters.dbg = dbgBreak
    });
    function getTargetProps(source) {
        var key, prop, props = [];
        if (typeof source === OBJECT) {
            for (key in source) {
                prop = source[key];
                if (!prop || !prop.toJSON || prop.toJSON()) {
                    if (!$isFunction(prop)) {
                        props.push({key: key, prop: prop})
                    }
                }
            }
        }
        return props
    }

    function htmlEncode(text) {
        return text != undefined ? rIsHtml.test(text) && ("" + text).replace(rHtmlEncode, getCharEntity) || text : ""
    }

    $converters({
        html: htmlEncode, attr: htmlEncode, url: function (text) {
            return text != undefined ? encodeURI("" + text) : text === null ? text : ""
        }
    });
    $viewsDelimiters();
    return $views
}));